# testing_queries.md
- Basic retrieval (`SELECT *`)
- Joins (multi-table)
- Aggregations (`GROUP BY`)
- Subqueries (scalar, correlated, EXISTS, IN)
- Optional BI-style analytical queries

Run all queries in SQL Developer using **F5** (Run Script) to capture full output.

---

# 1. BASIC RETRIEVAL (SELECT *)

### 1.1 All vehicles
```sql
SELECT * FROM VEHICLES;
```

### 1.2 First 20 drivers
```sql
SELECT * FROM DRIVERS FETCH FIRST 20 ROWS ONLY;
```

### 1.3 Maintenance records sample
```sql
SELECT * FROM MAINTENANCE_RECORDS FETCH FIRST 20 ROWS ONLY;
```

### 1.4 Current alerts
```sql
SELECT * FROM ALERTS WHERE status = 'OPEN';
```

---

# 2. JOIN QUERIES (MULTI-TABLE)

### 2.1 Trips with vehicle and driver details
```sql
SELECT 
    t.trip_id,
    v.plate_number,
    d.full_name AS driver_name,
    t.departure_time,
    t.arrival_time,
    t.trip_status
FROM TRIPS t
JOIN VEHICLES v ON t.vehicle_id = v.vehicle_id
JOIN DRIVERS d ON t.driver_id = d.driver_id
FETCH FIRST 20 ROWS ONLY;
```

### 2.2 Maintenance entries and part usage
```sql
SELECT
    m.maintenance_id,
    v.plate_number,
    m.maintenance_date,
    p.part_name,
    mp.quantity
FROM MAINTENANCE_RECORDS m
JOIN VEHICLES v ON m.vehicle_id = v.vehicle_id
JOIN MAINTENANCE_PARTS mp ON m.maintenance_id = mp.maintenance_id
JOIN PARTS p ON mp.part_id = p.part_id
FETCH FIRST 20 ROWS ONLY;
```

### 2.3 Trips with route distances
```sql
SELECT
    t.trip_id,
    v.plate_number,
    r.origin_city,
    r.destination_city,
    r.distance_km,
    t.trip_status
FROM TRIPS t
JOIN VEHICLES v ON t.vehicle_id = v.vehicle_id
JOIN ROUTES r ON t.route_id = r.route_id
FETCH FIRST 20 ROWS ONLY;
```

---

# 3. AGGREGATIONS (GROUP BY)

### 3.1 Number of trips per vehicle
```sql
SELECT 
    v.plate_number,
    COUNT(t.trip_id) AS total_trips
FROM VEHICLES v
LEFT JOIN TRIPS t ON v.vehicle_id = t.vehicle_id
GROUP BY v.plate_number
ORDER BY total_trips DESC
FETCH FIRST 10 ROWS ONLY;
```

### 3.2 Total maintenance cost per vehicle
```sql
SELECT 
    v.plate_number,
    NVL(SUM(m.cost_amount),0) AS total_cost
FROM VEHICLES v
LEFT JOIN MAINTENANCE_RECORDS m ON v.vehicle_id = m.vehicle_id
GROUP BY v.plate_number
ORDER BY total_cost DESC
FETCH FIRST 10 ROWS ONLY;
```

### 3.3 Incident counts by severity
```sql
SELECT severity, COUNT(*) AS count
FROM INCIDENTS
GROUP BY severity
ORDER BY count DESC;
```

### 3.4 Average delay by route
```sql
SELECT
    r.origin_city,
    r.destination_city,
    AVG(t.delay_minutes) AS avg_delay
FROM TRIPS t
JOIN ROUTES r ON t.route_id = r.route_id
GROUP BY r.origin_city, r.destination_city
ORDER BY avg_delay DESC NULLS LAST;
```

---

# 4. SUBQUERIES

### 4.1 Scalar subquery — longest delay trip
```sql
SELECT 
    trip_id, vehicle_id, driver_id, delay_minutes
FROM TRIPS
WHERE delay_minutes = (
    SELECT MAX(delay_minutes) FROM TRIPS
);
```

### 4.2 IN subquery — trips involving high maintenance cost vehicles
```sql
SELECT *
FROM TRIPS
WHERE vehicle_id IN (
    SELECT vehicle_id
    FROM MAINTENANCE_RECORDS
    GROUP BY vehicle_id
    HAVING SUM(cost_amount) > 3000
);
```

### 4.3 EXISTS subquery — vehicles with at least one incident
```sql
SELECT *
FROM VEHICLES v
WHERE EXISTS (
    SELECT 1
    FROM TRIPS t
    JOIN INCIDENTS i ON t.trip_id = i.trip_id
    WHERE t.vehicle_id = v.vehicle_id
);
```

### 4.4 Correlated subquery — parts with below-average stock
```sql
SELECT
    p.part_id,
    p.part_name,
    p.stock_qty
FROM PARTS p
WHERE p.stock_qty < (
    SELECT AVG(stock_qty) FROM PARTS
);
```

### 4.5 Subquery in SELECT — trip duration + route distance
```sql
SELECT
    trip_id,
    (arrival_time - departure_time) * 24 AS trip_hours,
    (SELECT distance_km FROM ROUTES r WHERE r.route_id = t.route_id) AS distance
FROM TRIPS t
FETCH FIRST 20 ROWS ONLY;
```

---

# 5. OPTIONAL ANALYTICAL QUERY (BI-READY)

### Ranking vehicles by trip count
```sql
SELECT 
    vehicle_id,
    plate_number,
    trip_count,
    RANK() OVER (ORDER BY trip_count DESC) AS rank_position
FROM (
    SELECT v.vehicle_id, v.plate_number, COUNT(t.trip_id) AS trip_count
    FROM VEHICLES v
    LEFT JOIN TRIPS t ON v.vehicle_id = t.vehicle_id
    GROUP BY v.vehicle_id, v.plate_number
)
FETCH FIRST 20 ROWS ONLY;
```

---

# 6. How to Document Results in GitHub

For each query above, include at least:
- A screenshot of SQL Developer output **OR**
- A copy/pasted text result  
- A short explanation (1 sentence) of what the query validates

Examples:
- “This query confirms the join between TRIPS and VEHICLES is correct.”  
- “This validates the aggregation of maintenance costs.”  

---

Your `testing_queries.md` is ready for GitHub.  
Would you like me to generate **verify_data_integrity.md** or **package all markdown files into a ZIP**?
